#! /usr/bin/env ruby
#  encoding: utf-8

# TODO: ./script/server should start your app on $PORT, and any other services
# you want to be running
#

require_relative '../lib/senv.rb'
require_relative '../lib/script.rb'
require_relative '../lib/assassin.rb'
require_relative '../lib/util.rb'

script do
  help <<~____
    # TODO
  ____

  run do
    start
  end

  run :start do
    start
  end

  def start
    setup

    @servers.each do |config|
      name = config.fetch(:name)
      port = config.fetch(:port)
      env = config.fetch(:env)

      background("./#{ name }/script/server", :env => env)

      wait_until_bound(port)
    end

    wait_for_servers

    teardown
  end

  def setup
  #
    @script_f = File.expand_path(__FILE__)
    @script_d = File.dirname(@script_f)
    @root_d = File.dirname(@script_d)

    Dir.chdir(@root_d)

  #
    Senv.load

  #
    @ENV = Hash.new

    @ENV['BACKEND_PORT']  = @options.fetch('backend_port'){ ENV['BACKEND_PORT'] || '4000' }
    @ENV['FRONTEND_PORT'] = @options.fetch('frontend_port'){ ENV['FRONTEND_PORT'] || '3000' }
    @ENV['PORT']          = @options.fetch('port'){ ENV['PORT'] || '8080' }

    @ENV['SENV']          = @options.fetch('senv'){ ENV['SENV'] || 'development' }
    @ENV['DEV']           = @options.fetch('dev'){ ENV['DEV'] || 'false' }

  #
    path = ENV['PATH']

    @ruby = utils.sys!('which ruby', :capture => true).strip
    bindir, bin = File.split(@ruby)
    path = [bindir, path].join(':')

    @node = utils.sys!('which node', :capture => true).strip
    bindir, bin = File.split(@node)
    path = [bindir, path].join(':')

    path = ['./node_modules/.bin', path].join(':')

    @ENV['PATH'] = path

  #
    @servers = [
      {
        :name => 'backend',
        :port => @ENV.fetch('BACKEND_PORT'),
        :env  => env_for('SERVER' => 'backend'),
      },
      {
        :name => 'frontend',
        :port => @ENV.fetch('FRONTEND_PORT'),
        :env  => env_for('SERVER' => 'frontend'),
      },
      {
        :name => 'proxy',
        :port => @ENV.fetch('PORT'),
        :env  => env_for('SERVER' => 'proxy'),
      },
    ]

    @threads = []

    STDOUT.sync = true
    STDERR.sync = true
  end

  def background(cmd, options = {})
    env = options.fetch(:env){ Hash.new }

    cmd = "#{ cmd } 2>&1"

    thread = Thread.new do
      Thread.current.abort_on_exception = true
      system(env, cmd)
    end

    @threads << thread

    thread
  end

  def wait_until_bound(port)
    bound = false

    4.times do
      sleep 0.1

      if Util.port_open?(port)
        sleep 0.42
      else
        bound = true
      end
    end

    bound
  end

  def wait_for_servers
    @threads.map{|thread| thread.join}
  end

  def teardown
  end
  
  def env_for(env = {})
    @ENV.merge(env)
  end
end
